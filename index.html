<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Escalade — V1.0</title>
	<meta name="description" content="Escalade Vector Tools — 8K Resolution with Smart Border Pinning." />

	<style>
		:root {
			--bg-1: #0f172a;
			--bg-2: #1e293b;
			--accent: #6366f1;
			--accent-dim: #4f46e5;
			--text: #f1f5f9;
			--muted: #94a3b8;
			--border: rgba(255, 255, 255, 0.1);
			--input-bg: rgba(0, 0, 0, 0.3);
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
			outline: none;
		}

		body {
			background: linear-gradient(135deg, var(--bg-1), var(--bg-2));
			color: var(--text);
			font-family: system-ui, -apple-system, sans-serif;
			height: 100vh;
			width: 100vw;
			overflow: hidden;
			display: flex;
			flex-direction: column;
		}

		/* Drag Overlay State */
		body.dragging::after {
			content: 'Drop Image Here';
			position: absolute;
			inset: 0;
			background: rgba(99, 102, 241, 0.2);
			backdrop-filter: blur(4px);
			z-index: 100;
			display: grid;
			place-items: center;
			font-size: 2rem;
			font-weight: 700;
			color: #fff;
			pointer-events: none;
			border: 4px dashed var(--accent);
		}

		header {
			height: 56px;
			padding: 0 1.25rem;
			border-bottom: 1px solid var(--border);
			display: flex;
			align-items: center;
			background: rgba(15, 23, 42, 0.95);
			flex-shrink: 0;
			justify-content: space-between;
			z-index: 20;
		}

		.brand {
			font-weight: 700;
			font-size: 1.05rem;
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}

		.tag {
			font-size: 0.6rem;
			background: rgba(99, 102, 241, 0.15);
			color: #818cf8;
			padding: 2px 6px;
			border-radius: 4px;
			border: 1px solid rgba(99, 102, 241, 0.25);
			text-transform: uppercase;
			font-weight: 600;
		}

		main {
			flex: 1;
			display: flex;
			overflow: hidden;
			position: relative;
		}

		aside {
			width: 320px;
			min-width: 320px;
			border-right: 1px solid var(--border);
			background: rgba(15, 23, 42, 0.6);
			padding: 1.25rem;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			gap: 1.25rem;
			height: 100%;
			flex-shrink: 0;
			z-index: 10;
			backdrop-filter: blur(10px);
		}

		@media (max-width: 800px) {
			main {
				flex-direction: column;
				overflow-y: auto;
			}

			aside {
				width: 100%;
				height: auto;
				border-right: none;
				border-bottom: 1px solid var(--border);
				overflow-y: visible;
			}

			body {
				overflow: auto;
				height: auto;
			}

			.workspace {
				height: 500px;
				min-height: 50vh;
			}
		}

		.control-group {
			display: flex;
			flex-direction: column;
			gap: 0.85rem;
		}

		.group-title {
			font-size: 0.7rem;
			font-weight: 700;
			color: var(--muted);
			text-transform: uppercase;
			border-bottom: 1px solid var(--border);
			padding-bottom: 0.4rem;
		}

		.ctrl {
			display: flex;
			justify-content: space-between;
			align-items: center;
			font-size: 0.8rem;
			margin-bottom: 0.3rem;
		}

		.val {
			font-family: monospace;
			color: var(--accent);
			font-size: 0.75rem;
		}

		input[type=range] {
			width: 100%;
			-webkit-appearance: none;
			background: transparent;
			cursor: pointer;
			display: block;
		}

		input[type=range]::-webkit-slider-runnable-track {
			background: var(--border);
			height: 4px;
			border-radius: 2px;
		}

		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			height: 14px;
			width: 14px;
			border-radius: 50%;
			background: var(--accent);
			margin-top: -5px;
			transition: transform 0.1s;
		}

		select {
			width: 100%;
			background: var(--input-bg);
			border: 1px solid var(--border);
			color: var(--text);
			padding: 0.4rem;
			border-radius: 6px;
			font-size: 0.8rem;
		}

		.chk {
			display: flex;
			align-items: center;
			gap: 0.6rem;
			font-size: 0.8rem;
			cursor: pointer;
			user-select: none;
		}

		input[type=checkbox] {
			accent-color: var(--accent);
			width: 14px;
			height: 14px;
		}

		.btn {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			gap: 0.5rem;
			padding: 0.55rem 1rem;
			border-radius: 6px;
			font-weight: 600;
			font-size: 0.85rem;
			cursor: pointer;
			transition: all 0.2s;
			border: none;
			text-decoration: none;
		}

		.btn-primary {
			background: var(--accent);
			color: #0f172a;
		}

		.btn-primary:hover {
			background: var(--accent-dim);
		}

		.btn-primary:disabled {
			opacity: 0.5;
			filter: grayscale(1);
			cursor: not-allowed;
		}

		.btn-ghost {
			background: transparent;
			color: var(--muted);
			border: 1px solid var(--border);
		}

		.btn-ghost:hover {
			border-color: var(--text);
			color: var(--text);
			background: rgba(255, 255, 255, 0.05);
		}

		/* --- SPECIAL TIP BUTTON STYLE --- */
		.btn-tip {
			background: linear-gradient(135deg, #fbbf24, #d97706);
			color: #1e293b;
			border: 1px solid rgba(251, 191, 36, 0.5);
			font-weight: 700;
			box-shadow: 0 4px 6px -1px rgba(217, 119, 6, 0.2);
			transition: all 0.2s ease;
		}

		.btn-tip:hover {
			transform: translateY(-1px);
			box-shadow: 0 10px 15px -3px rgba(217, 119, 6, 0.3);
			filter: brightness(1.1);
		}

		.workspace {
			flex: 1;
			position: relative;
			background-color: #020617;
			background-image: radial-gradient(#1e293b 1px, transparent 1px);
			background-size: 20px 20px;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		.preview-container {
			flex: 1;
			display: grid;
			place-items: center;
			padding: 2rem;
			overflow: hidden;
		}

		.view-stack {
			display: grid;
			grid-template-areas: "stack";
			max-width: 100%;
			max-height: 100%;
			box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
			border: 1px solid var(--border);
		}

		.view-layer {
			grid-area: stack;
			display: block;
			width: 100%;
			height: auto;
			object-fit: contain;
		}

		#rasterView {
			z-index: 2;
			opacity: 0;
			transition: opacity 0.15s ease-out;
			pointer-events: none;
		}

		#vectorCanvas {
			z-index: 1;
			background: white;
			cursor: crosshair;
		}

		.empty-state {
			position: absolute;
			inset: 0;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			color: var(--muted);
			background: rgba(15, 23, 42, 0.85);
			z-index: 5;
			font-size: 0.9rem;
		}

		.loading-overlay {
			position: absolute;
			inset: 0;
			background: rgba(15, 23, 42, 0.95);
			backdrop-filter: blur(4px);
			z-index: 50;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.2s;
		}

		.loading-overlay.active {
			opacity: 1;
			pointer-events: auto;
		}

		.spinner {
			width: 32px;
			height: 32px;
			border: 3px solid rgba(255, 255, 255, 0.1);
			border-top-color: var(--accent);
			border-radius: 50%;
			animation: spin 0.8s linear infinite;
			margin-bottom: 1rem;
		}

		@keyframes spin {
			to {
				transform: rotate(360deg);
			}
		}

		.progress-bar {
			width: 180px;
			height: 4px;
			background: rgba(255, 255, 255, 0.1);
			border-radius: 2px;
			overflow: hidden;
		}

		.progress-fill {
			height: 100%;
			width: 0%;
			background: var(--accent);
			transition: width 0.2s;
		}

		.file-input-wrapper {
			position: relative;
			width: 100%;
		}

		.file-input-wrapper input {
			position: absolute;
			inset: 0;
			opacity: 0;
			cursor: pointer;
		}

		.error-toast {
			position: absolute;
			bottom: 20px;
			right: 20px;
			background: #7f1d1d;
			color: #fecaca;
			border: 1px solid #ef4444;
			padding: 1rem;
			border-radius: 8px;
			font-size: 0.85rem;
			max-width: 300px;
			display: none;
			z-index: 100;
			box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
		}

		/* --- MODAL STYLES --- */
		.modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(5px);
			z-index: 200;
			display: none;
			place-items: center;
			padding: 1rem;
		}

		.modal-overlay.active {
			display: grid;
		}

		.modal-content {
			background: var(--bg-2);
			border: 1px solid var(--border);
			padding: 1.5rem;
			border-radius: 12px;
			max-width: 500px;
			width: 100%;
			box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
			display: flex;
			flex-direction: column;
			gap: 1rem;
		}

		.tos-scroll {
			background: rgba(0, 0, 0, 0.3);
			padding: 1rem;
			border-radius: 6px;
			height: 220px;
			overflow-y: auto;
			font-size: 0.85rem;
			color: var(--muted);
			line-height: 1.5;
			border: 1px solid var(--border);
		}

		.tos-scroll h4 {
			color: var(--text);
			margin: 1rem 0 0.4rem 0;
			font-size: 0.9rem;
		}

		.tos-scroll h4:first-child {
			margin-top: 0;
		}
	</style>
</head>

<body>

	<header>
		<div class="brand">
			<svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2.5" viewBox="0 0 24 24">
				<path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" />
			</svg>
			Escalade <span class="tag">V1.0</span>
		</div>
		<div style="display:flex; gap:0.5rem; align-items:center;">
			<span class="val" style="color: var(--muted); margin-right:0.5rem;" id="imgMeta"></span>
			<a href="https://donate.stripe.com/4gM4gBcmO1nG9PA5zF1B601" target="_blank" class="btn btn-tip"
				style="text-decoration:none; padding: 0.55rem 0.8rem;">Tip the Developer</a>
			<button id="tosBtn" class="btn btn-ghost" style="padding: 0.55rem 0.8rem;">Terms</button>
			<button id="downloadBtn" class="btn btn-ghost" disabled>Download SVG</button>
		</div>
	</header>

	<main>
		<aside>
			<div class="control-group">
				<div class="group-title">Vectorize</div>
				<div class="file-input-wrapper">
					<button class="btn btn-ghost" style="width:100%">Upload Image</button>
					<input type="file" id="fileInput" accept="image/*">
				</div>

				<div style="margin-top:0.25rem;">
					<div class="ctrl"><span>Preset</span></div>
					<select id="presetSelect">
						<option value="photo">Photo (Ultra)</option>
						<option value="poster" selected>Poster / Flat</option>
						<option value="scan">Scan / B&W</option>
					</select>
				</div>
				<div>
					<div class="ctrl"><span>Resolution</span> <span id="val_res" class="val">2048</span></div>
					<input type="range" id="maxRes" min="1024" max="8192" step="512" value="2048">
				</div>
				<label class="chk" style="color:var(--accent); font-weight:600">
					<input type="checkbox" id="upscale"> 2x Super-Sample
				</label>
			</div>

			<div class="control-group">
				<div class="group-title">1. Color Fidelity</div>
				<div>
					<div class="ctrl"><span>Colors (Max)</span> <span id="val_k" class="val">32</span></div>
					<input type="range" id="k" min="2" max="256" value="32">
					<div style="font-size:0.65rem; color:var(--muted); margin-top:2px;">Max = True Color (Weighted).
					</div>
				</div>
				<div>
					<div class="ctrl"><span>Splash Tolerance</span> <span id="val_tol" class="val">35</span></div>
					<input type="range" id="tolerance" min="1" max="100" value="35">
				</div>
				<div>
					<div class="ctrl"><span>Min Area Size</span> <span id="val_om" class="val">20</span></div>
					<input type="range" id="pathomit" min="1" max="200" value="20">
				</div>
				<label class="chk"><input type="checkbox" id="denoise"> Denoise (Smooth Source)</label>
			</div>

			<div class="control-group">
				<div class="group-title">2. Geometry & Finish</div>
				<div>
					<div class="ctrl"><span>Accuracy (Fit)</span> <span id="val_lt" class="val">0.5</span></div>
					<input type="range" id="ltres" min="0.1" max="4" step="0.1" value="0.5">
				</div>
				<div>
					<div class="ctrl"><span>Corner Smooth</span> <span id="val_sm" class="val">0</span></div>
					<input type="range" id="smooth" min="0" max="5" step="1" value="0">
				</div>
				<div>
					<div class="ctrl"><span>Roundness (Border Safe)</span> <span id="val_qt" class="val">0</span>
					</div>
					<input type="range" id="qtres" min="0" max="4" step="0.1" value="0">
				</div>
				<div>
					<div class="ctrl"><span>Seam Thickness</span> <span id="val_str" class="val">2.0</span></div>
					<input type="range" id="strokeW" min="0" max="4" step="0.5" value="2.0">
				</div>
			</div>

			<div
				style="margin-top:auto; padding-top:1rem; border-top:1px solid var(--border); display:flex; gap:0.5rem; align-items:center;">
				<label class="chk" style="flex:1"><input type="checkbox" id="autoRun" checked> Auto-update</label>
				<button id="runBtn" class="btn btn-primary" style="flex:1">Vectorize</button>
			</div>
		</aside>

		<div class="workspace">
			<div id="loader" class="loading-overlay">
				<div class="spinner"></div>
				<div class="val" style="margin-bottom:0.5rem" id="statusText">Initializing...</div>
				<div class="progress-bar">
					<div class="progress-fill" id="pBar"></div>
				</div>
			</div>

			<div class="preview-container">
				<div id="emptyState" class="empty-state">
					<p>Drag & Drop or Paste Image (Ctrl+V)</p>
				</div>
				<div id="viewStack" class="view-stack" style="display:none">
					<img id="rasterView" class="view-layer">
					<canvas id="vectorCanvas" class="view-layer"></canvas>
				</div>
			</div>

			<div
				style="position:absolute; top:1rem; right:1.5rem; background:rgba(0,0,0,0.6); padding:4px; border-radius:8px; display:flex; gap:4px; border:1px solid var(--border); z-index:30;">
				<button class="btn btn-ghost" style="padding:4px 8px; font-size:0.75rem" id="toggleView">Hold to
					Compare</button>
			</div>
		</div>
	</main>

	<div id="tosModal" class="modal-overlay">
		<div class="modal-content">
			<h3 style="font-size:1.1rem; color:var(--text)">Terms of Use</h3>
			<div class="tos-scroll">
				<h4>1. License Grant</h4>
				<p>Escalade Vector Tools is provided for use "as-is". You may use the generated SVG assets for any
					personal or commercial purpose.</p>

				<h4>2. Restrictions</h4>
				<p>You may not redistribute, sub-license, or sell the source code of this application. Modification of
					the internal algorithms for resale is prohibited.</p>

				<h4>3. Privacy</h4>
				<p>This tool operates entirely client-side. Your images are processed within your browser's memory and
					are not uploaded to any external server.</p>

				<h4>4. Disclaimer</h4>
				<p>The software is provided without warranty of any kind. The authors are not liable for any damages or
					data loss arising from its use.</p>
			</div>
			<button id="closeTos" class="btn btn-primary" style="width:100%">I Understand</button>
		</div>
	</div>

	<div id="errToast" class="error-toast"></div>
	<canvas id="hiddenCanvas" style="display:none"></canvas>

	<script id="worker-code" type="javascript/worker">
    /* ESCALADE V22: GAUSSIAN SMOOTH + PINNED */
    
    let lastYield = 0;
    function checkYield() {
        if (Date.now() - lastYield > 30) { 
            lastYield = Date.now();
            return new Promise(r => setTimeout(r, 0));
        }
        return null;
    }

    function diff(r1,g1,b1, r2,g2,b2) {
       return Math.sqrt((r1-r2)**2 + (g1-g2)**2 + (b1-b2)**2);
    }

    function applyMedianFilter(w, h, data) {
       const copy = new Uint8ClampedArray(data);
       for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
             const i = (y * w + x) * 4;
             const r = [], g = [], b = [];
             for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                   const idx = ((y + ky) * w + (x + kx)) * 4;
                   r.push(copy[idx]); g.push(copy[idx+1]); b.push(copy[idx+2]);
                }
             }
             r.sort((a,z)=>a-z); g.sort((a,z)=>a-z); b.sort((a,z)=>a-z);
             data[i] = r[4]; data[i+1] = g[4]; data[i+2] = b[4];
          }
       }
    }

    async function runSplashFill(w, h, data, opts) {
        const n = w * h;
        const visited = new Uint8Array(n);
        const regionMap = new Int32Array(n).fill(-1);
        const regionColors = []; 
        const regionWeights = []; 
        
        const tol = opts.tolerance; 
        const minSize = opts.pathomit;

        for(let y=0; y<h; y++) {
            const p = await checkYield(); if(p) await p;
            for(let x=0; x<w; x++) {
                const i = y*w+x;
                if(visited[i]) continue;

                const r0 = data[i*4], g0 = data[i*4+1], b0 = data[i*4+2];
                const stack = [i];
                visited[i] = 1;
                const regionIndices = [i];
                let sumR = r0, sumG = g0, sumB = b0;
                
                let ptr = 0;
                while(ptr < stack.length) {
                    const curr = stack[ptr++];
                    const cy = (curr / w)|0; const cx = curr % w;
                    const nbs = [];
                    if(cx>0) nbs.push(curr-1);
                    if(cx<w-1) nbs.push(curr+1);
                    if(cy>0) nbs.push(curr-w);
                    if(cy<h-1) nbs.push(curr+w);

                    for(let nb of nbs) {
                        if(!visited[nb]) {
                            const nr=data[nb*4], ng=data[nb*4+1], nb_b=data[nb*4+2];
                            if(diff(r0,g0,b0, nr,ng,nb_b) <= tol) {
                                visited[nb] = 1;
                                stack.push(nb);
                                regionIndices.push(nb);
                                sumR += nr; sumG += ng; sumB += nb_b;
                            }
                        }
                    }
                }

                if (regionIndices.length > minSize) {
                    const avgR = Math.round(sumR / regionIndices.length);
                    const avgG = Math.round(sumG / regionIndices.length);
                    const avgB = Math.round(sumB / regionIndices.length);
                    const regionID = regionColors.length;
                    regionColors.push([avgR, avgG, avgB]);
                    regionWeights.push(regionIndices.length); 
                    for(let idx of regionIndices) regionMap[idx] = regionID;
                }
            }
        }
        return { regionColors, regionWeights, regionMap };
    }

    function clusterRegions(regionColors, regionWeights, k) {
        if (regionColors.length <= k || k >= 250) {
            return { palette: regionColors, map: regionColors.map((_,i)=>i) };
        }

        let palette = [];
        for(let i=0; i<k; i++) {
            let r = Math.floor(Math.random()*regionColors.length);
            palette.push(regionColors[r]);
        }
        
        let clusters = new Int32Array(regionColors.length);
        for(let it=0; it<10; it++) { 
            let sums = new Float32Array(k*3);
            let counts = new Float32Array(k); 
            for(let i=0; i<regionColors.length; i++) {
                const c = regionColors[i];
                const w = Math.sqrt(regionWeights[i]); 
                let best = 0; let minD = 1e9;
                for(let j=0; j<k; j++) {
                    const d = (c[0]-palette[j][0])**2 + (c[1]-palette[j][1])**2 + (c[2]-palette[j][2])**2;
                    if(d < minD) { minD = d; best = j; }
                }
                clusters[i] = best;
                sums[best*3]   += c[0] * w;
                sums[best*3+1] += c[1] * w;
                sums[best*3+2] += c[2] * w;
                counts[best]   += w;
            }
            for(let j=0; j<k; j++) {
                if(counts[j]>0) {
                    palette[j] = [sums[j*3]/counts[j], sums[j*3+1]/counts[j], sums[j*3+2]/counts[j]];
                }
            }
        }
        return { palette, map: clusters };
    }

    function tracePath(sx, sy, id, w, h, map) {
       const path = []; 
       let x = sx, y = sy;
       let dir = 0; 
       const dx = [0, 1, 0, -1];
       const dy = [-1, 0, 1, 0];
       path.push(x, y);
       let limit = 200000;
       let loops = 0;
       do {
          let moved = false;
          const turn = [3, 0, 1, 2]; 
          for(let t of turn) {
             const nd = (dir + t) % 4;
             const nx = x + dx[nd];
             const ny = y + dy[nd];
             if (nx>=0 && nx<w && ny>=0 && ny<h && map[ny*w+nx] === id) {
                x = nx; y = ny; dir = nd;
                path.push(x, y); moved = true; break;
             }
          }
          if (!moved) break;
          loops++;
          if (loops > limit) break; 
       } while ((x!==sx || y!==sy));
       return path;
    }

    function simplify(points, tol) {
       const len = points.length/2;
       if (len <= 2) return points;
       const sq = tol*tol;
       const keep = new Uint8Array(len);
       keep[0]=1; keep[len-1]=1;
       const stack = [0, len-1];
       while(stack.length) {
          const end=stack.pop(); const start=stack.pop();
          let maxD=0; let idx=0;
          const x1=points[start*2], y1=points[start*2+1];
          const x2=points[end*2],   y2=points[end*2+1];
          const dx=x2-x1, dy=y2-y1; 
          const segmentLen=dx*dx+dy*dy;
          for(let i=start+1; i<end; i++) {
             const px=points[i*2], py=points[i*2+1];
             let d=0;
             if(segmentLen===0) d=(px-x1)**2+(py-y1)**2;
             else {
                let t=((px-x1)*dx+(py-y1)*dy)/segmentLen;
                t=Math.max(0,Math.min(1,t));
                d=(px-(x1+t*dx))**2+(py-(y1+t*dy))**2;
             }
             if(d>maxD) { maxD=d; idx=i; }
          }
          if(maxD>sq) { keep[idx]=1; stack.push(start, idx, idx, end); }
       }
       const r=[]; for(let i=0; i<len; i++) if(keep[i]) r.push(points[i*2], points[i*2+1]);
       return r;
    }
    
    // GAUSSIAN SMOOTH (Vector Laplacian)
    function applyGaussianSmooth(points, iterations) {
        if(iterations <= 0) return points;
        let src = points;
        
        for(let k=0; k<iterations; k++) {
            const dst = [];
            const len = src.length/2;
            for(let i=0; i<len; i++) {
                const prev = (i-1+len)%len;
                const next = (i+1)%len;
                
                const px = src[prev*2], py = src[prev*2+1];
                const cx = src[i*2],    cy = src[i*2+1];
                const nx = src[next*2], ny = src[next*2+1];
                
                // 0.25 (Neighbor) + 0.5 (Self) + 0.25 (Neighbor)
                dst.push(
                    0.25*px + 0.5*cx + 0.25*nx,
                    0.25*py + 0.5*cy + 0.25*ny
                );
            }
            src = dst;
        }
        return src;
    }

    self.onmessage = async function(e) {
       const {cmd, buffer, w, h, opts} = e.data;
       if(cmd==='run') {
          try {
              const data = new Uint8ClampedArray(buffer);
              if (opts.denoise) applyMedianFilter(w, h, data);

              postMessage({t:'status', msg:'Detecting Shapes...', p:10});
              const { regionColors, regionWeights, regionMap } = await runSplashFill(w, h, data, opts);
              
              let statusMsg = `Clustering ${regionColors.length} Areas...`;
              if (opts.k >= 250) statusMsg = `Processing ${regionColors.length} Areas (True Color)...`;
              
              postMessage({t:'status', msg: statusMsg, p:30});
              const { palette, map: clusterMap } = clusterRegions(regionColors, regionWeights, opts.k);
              
              for(let i=0; i<regionMap.length; i++) {
                  const oldId = regionMap[i];
                  if(oldId !== -1) regionMap[i] = clusterMap[oldId];
              }

              const visited = new Uint8Array(w*h);
              const resultLayers = [];
              
              postMessage({t:'status', msg:`Tracing Vectors...`, p:40});

              for(let y=0; y<h; y++) {
                 const p = await checkYield(); if(p) await p; 
                 
                 for(let x=0; x<w; x++) {
                    const i = y*w+x;
                    const id = regionMap[i];
                    
                    if (id !== -1 && !visited[i]) {
                        const path = tracePath(x, y, id, w, h, regionMap);
                        
                        // Flood fill to mark visited
                        const stack = [y*w+x];
                        visited[y*w+x] = 1;
                        let count=0;
                        while(stack.length) {
                            const curr = stack.pop();
                            const cy = (curr/w)|0; const cx = curr%w;
                            if(cx>0 && regionMap[curr-1]===id && !visited[curr-1]) { visited[curr-1]=1; stack.push(curr-1); }
                            if(cx<w-1 && regionMap[curr+1]===id && !visited[curr+1]) { visited[curr+1]=1; stack.push(curr+1); }
                            if(cy>0 && regionMap[curr-w]===id && !visited[curr-w]) { visited[curr-w]=1; stack.push(curr-w); }
                            if(cy<h-1 && regionMap[curr+w]===id && !visited[curr+w]) { visited[curr+w]=1; stack.push(curr+w); }
                            count++; if(count>3000000) break;
                        }
                        
                        if (path.length > 4) {
                            let finalPath = simplify(path, opts.ltres);
                            
                            // 2. Smooth Geometry (Gaussian)
                            if (opts.smoothness > 0) {
                                finalPath = applyGaussianSmooth(finalPath, opts.smoothness * 2);
                            }
                            
                            resultLayers.push({
                                color: palette[id],
                                points: new Float32Array(finalPath),
                                size: count 
                            });
                        }
                    }
                 }
              }
              
              resultLayers.sort((a,b) => b.size - a.size);
              postMessage({t:'result', layers: resultLayers}, resultLayers.map(l => l.points.buffer));
              
          } catch(err) {
              console.error(err);
              postMessage({t:'error', msg: err.message});
          }
       }
    };
  </script>

	<script>
		const $ = id => document.getElementById(id);
		let worker = null;
		let currentImg = null;
		let lastResult = null;
		let debounceTimer = null;
		let w = 0, h = 0;

		function iteratePath(pts, qtres, canvasW, canvasH, callbacks) {
			const len = pts.length / 2;
			if (len < 2) return;
			callbacks.move(pts[0], pts[1]);

			const isBorder = (x, y) => x <= 0 || y <= 0 || x >= canvasW - 1 || y >= canvasH - 1;

			if (qtres < 0.1) {
				for (let i = 1; i < len; i++) callbacks.line(pts[i * 2], pts[i * 2 + 1]);
			} else {
				for (let i = 1; i < len; i++) {
					const prev = (i - 1) * 2;
					const curr = i * 2;
					const next = ((i + 1) % len) * 2;
					const p0x = pts[prev], p0y = pts[prev + 1];
					const p1x = pts[curr], p1y = pts[curr + 1];
					const p2x = pts[next], p2y = pts[next + 1];

					if (isBorder(p1x, p1y) && isBorder(p2x, p2y)) {
						callbacks.line(p1x, p1y);
						continue;
					}

					const a1 = Math.atan2(p0y - p1y, p0x - p1x);
					const a2 = Math.atan2(p2y - p1y, p2x - p1x);
					let angle = Math.abs(a1 - a2);
					if (angle > Math.PI) angle = 2 * Math.PI - angle;

					if (angle < (1.0 / qtres)) {
						callbacks.line(p1x, p1y);
					} else {
						const mx = (p1x + p2x) / 2;
						const my = (p1y + p2y) / 2;
						callbacks.curve(p1x, p1y, mx, my);
					}
				}
			}
			callbacks.close();
		}

		function renderCanvas(layers) {
			const cvs = $('vectorCanvas');
			cvs.width = w; cvs.height = h;
			const ctx = cvs.getContext('2d');
			const strokeW = +$('strokeW').value;
			const qtres = +$('qtres').value;

			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
			ctx.lineJoin = 'round'; ctx.lineCap = 'round';

			layers.forEach(layer => {
				const c = layer.color;
				const cssCol = `rgb(${Math.round(c[0])},${Math.round(c[1])},${Math.round(c[2])})`;
				ctx.fillStyle = cssCol;
				ctx.strokeStyle = cssCol;
				ctx.lineWidth = strokeW;

				ctx.beginPath();
				iteratePath(layer.points, qtres, w, h, {
					move: (x, y) => ctx.moveTo(x, y),
					line: (x, y) => ctx.lineTo(x, y),
					curve: (cx, cy, x, y) => ctx.quadraticCurveTo(cx, cy, x, y),
					close: () => ctx.closePath()
				});

				ctx.fill();
				if (strokeW > 0) ctx.stroke();
			});
		}

		function downloadSVG() {
			if (!lastResult) return;
			const qtres = +$('qtres').value;
			const strokeW = +$('strokeW').value;
			let svg = `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg" style="background:#000" shape-rendering="geometricPrecision">`;

			lastResult.layers.forEach(layer => {
				const c = layer.color;
				const col = `rgb(${Math.round(c[0])},${Math.round(c[1])},${Math.round(c[2])})`;
				let d = "";
				iteratePath(layer.points, qtres, w, h, {
					move: (x, y) => d += `M${x.toFixed(2)} ${y.toFixed(2)}`,
					line: (x, y) => d += `L${x.toFixed(2)} ${y.toFixed(2)}`,
					curve: (cx, cy, x, y) => d += `Q${cx.toFixed(2)} ${cy.toFixed(2)} ${x.toFixed(2)} ${y.toFixed(2)}`,
					close: () => d += "Z "
				});
				svg += `<path d="${d}" fill="${col}" stroke="${col}" stroke-width="${strokeW}" stroke-linejoin="round" />`;
			});
			svg += "</svg>";
			const blob = new Blob([svg], { type: 'image/svg+xml' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a'); a.href = url; a.download = 'vectorized.svg'; a.click();
		}

		function initWorker() {
			if (worker) worker.terminate();
			const blob = new Blob([$('worker-code').textContent], { type: "text/javascript" });
			worker = new Worker(URL.createObjectURL(blob));
			worker.onmessage = (e) => {
				const d = e.data;
				if (d.t === 'status') {
					$('statusText').textContent = d.msg;
					$('pBar').style.width = d.p + '%';
				} else if (d.t === 'result') {
					lastResult = d;
					$('loader').classList.remove('active');
					renderCanvas(d.layers);
					$('downloadBtn').disabled = false;
				} else if (d.t === 'error') {
					$('loader').classList.remove('active');
					$('errToast').textContent = d.msg;
					$('errToast').style.display = 'block';
				}
			};
		}

		const PRESETS = {
			// All profiles now use strokeW: 2.0, ltres: 0.5, qtres: 0.0, smoothness: 0
			// and explicit denoise: false
			photo: { tolerance: 20, k: 256, ltres: 0.5, qtres: 0.0, pathomit: 10, maxRes: 2048, strokeW: 2.0, smoothness: 0, denoise: false },
			poster: { tolerance: 35, k: 32, ltres: 0.5, qtres: 0.0, pathomit: 20, maxRes: 2048, strokeW: 2.0, smoothness: 0, denoise: false },
			scan: { tolerance: 50, k: 4, ltres: 0.5, qtres: 0.0, pathomit: 15, maxRes: 2500, strokeW: 2.0, smoothness: 0, denoise: false }
		};

		function applyPreset(key) {
			const p = PRESETS[key]; if (!p) return;
			for (let k in p) {
				const id = k === 'smoothness' ? 'smooth' : k;
				const el = $(id);
				if (el) {
					if (el.type === 'checkbox') el.checked = p[k];
					else el.value = p[k];
					updateVal(id);
				}
			}
			scheduleRun();
		}

		function updateVal(id) {
			const el = $(id);
			if (el.type !== 'checkbox') {
				let k = id.replace('res', '').replace('T', '');
				if (id === 'tolerance') k = 'tol';
				if (id === 'maxRes') k = 'res';
				if (id === 'strokeW') k = 'str';
				if (id === 'pathomit') k = 'om';
				if (id === 'smooth') k = 'sm';

				const disp = $('val_' + k);
				if (disp) disp.textContent = el.value;
				if (id === 'k' && +el.value >= 250) disp.textContent = "True";
			}
		}

		function scheduleRun() {
			if (!$('autoRun').checked || !currentImg) return;
			clearTimeout(debounceTimer);
			debounceTimer = setTimeout(runVectorization, 150);
		}

		function handleFile(file) {
			if (!file) return;
			if (!file.type.startsWith('image/')) {
				$('errToast').textContent = "That file is not an image.";
				$('errToast').style.display = 'block';
				setTimeout(() => $('errToast').style.display = 'none', 3000);
				return;
			}
			$('emptyState').style.display = 'none';
			$('viewStack').style.display = 'grid';
			$('downloadBtn').disabled = true;
			const url = URL.createObjectURL(file);
			currentImg = new Image();
			currentImg.onload = () => {
				$('rasterView').src = url;
				$('imgMeta').textContent = `${file.name} (${currentImg.naturalWidth}×${currentImg.naturalHeight})`;
				if ($('autoRun').checked) runVectorization();
			};
			currentImg.src = url;
		}

		function runVectorization() {
			if (!currentImg) return;
			initWorker();
			$('loader').classList.add('active');
			$('statusText').textContent = "Processing...";
			$('pBar').style.width = '5%';
			const cvs = $('hiddenCanvas'); const ctx = cvs.getContext('2d');

			let baseW = currentImg.naturalWidth; let baseH = currentImg.naturalHeight;
			let MAX = +$('maxRes').value;
			if (baseW > MAX || baseH > MAX) {
				const scale = Math.min(MAX / baseW, MAX / baseH);
				baseW = Math.round(baseW * scale); baseH = Math.round(baseH * scale);
			}

			if ($('upscale').checked) { baseW *= 2; baseH *= 2; $('statusText').textContent = "Super-Sampling..."; }

			w = baseW; h = baseH;
			cvs.width = w; cvs.height = h;
			ctx.drawImage(currentImg, 0, 0, w, h);
			const imgData = ctx.getImageData(0, 0, w, h);

			const opts = {
				tolerance: +$('tolerance').value, k: +$('k').value,
				ltres: +$('ltres').value, qtres: +$('qtres').value,
				pathomit: +$('pathomit').value, denoise: $('denoise').checked,
				smoothness: +$('smooth').value
			};
			worker.postMessage({ cmd: 'run', buffer: imgData.data.buffer, w: w, h: h, opts: opts }, [imgData.data.buffer]);
		}

		$('fileInput').addEventListener('change', e => handleFile(e.target.files[0]));
		$('runBtn').addEventListener('click', runVectorization);
		$('downloadBtn').addEventListener('click', downloadSVG);

		const tv = $('toggleView'); const rv = $('rasterView');
		const show = (e) => { e.preventDefault(); rv.style.opacity = 1; };
		const hide = (e) => { e.preventDefault(); rv.style.opacity = 0; };
		tv.addEventListener('mousedown', show); tv.addEventListener('mouseup', hide); tv.addEventListener('mouseleave', hide);
		tv.addEventListener('touchstart', show); tv.addEventListener('touchend', hide);

		$('presetSelect').addEventListener('change', (e) => applyPreset(e.target.value));

		['tolerance', 'k', 'ltres', 'qtres', 'pathomit', 'maxRes', 'strokeW', 'smooth'].forEach(id => {
			$(id).addEventListener('input', () => {
				updateVal(id);
				if (id === 'qtres' || id === 'strokeW') { if (lastResult) renderCanvas(lastResult.layers); }
				else scheduleRun();
			});
		});
		$('denoise').addEventListener('change', scheduleRun);
		$('upscale').addEventListener('change', scheduleRun);

		// --- NEW: TOS Modal Handlers ---
		$('tosBtn').addEventListener('click', () => {
			$('tosModal').classList.add('active');
		});
		$('closeTos').addEventListener('click', () => {
			$('tosModal').classList.remove('active');
		});
		// Close modal when clicking outside content
		$('tosModal').addEventListener('click', (e) => {
			if (e.target.id === 'tosModal') $('tosModal').classList.remove('active');
		});

		// --- Global Drag & Drop + Paste ---
		document.addEventListener('paste', e => {
			const items = (e.clipboardData || e.originalEvent.clipboardData).items;
			for (let item of items) {
				if (item.kind === 'file' && item.type.startsWith('image/')) {
					handleFile(item.getAsFile());
					break;
				}
			}
		});

		const body = document.body;
		let dragCounter = 0;

		['dragenter', 'dragover', 'dragleave', 'drop'].forEach(name => {
			body.addEventListener(name, e => {
				e.preventDefault(); e.stopPropagation();
			});
		});

		body.addEventListener('dragenter', () => {
			dragCounter++;
			body.classList.add('dragging');
		});

		body.addEventListener('dragleave', () => {
			dragCounter--;
			if (dragCounter <= 0) body.classList.remove('dragging');
		});

		body.addEventListener('drop', e => {
			dragCounter = 0;
			body.classList.remove('dragging');
			const dt = e.dataTransfer;
			if (dt.files && dt.files.length) {
				handleFile(dt.files[0]);
			}
		});

	</script>

	  <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "7388a2f5005044638ad1d44433aba727"}'></script><!-- End Cloudflare Web Analytics -->

</body>

</html>