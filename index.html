<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AIME — Local/API Models + Personalized Indexes</title>
  <style>
    :root{
      --bg: #0b0f14; --fg:#e7eef7; --muted:#9bb0c9; --panel:#121823; --accent:#6ae3ff; --accent-2:#a6ff9f;
      --card:#0f141c; --border:#1f2a3a; --danger:#ff6b6b; --ok:#66d9a8; --warn:#ffd166; --code:#0a0f15;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0a0e13 0%, #0b1018 60%, #0b0f14 100%);color:var(--fg);font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif}
    .app{display:grid;grid-template-rows:auto 1fr;min-height:100%}
    header{position:sticky;top:0;background:rgba(10,15,22,.8);backdrop-filter: blur(12px);border-bottom:1px solid var(--border);z-index:10}
    .bar{display:flex;align-items:center;gap:12px;padding:12px 16px;max-width:1200px;margin:0 auto}
    .logo{display:flex;align-items:center;gap:10px;font-weight:700;letter-spacing:.3px}
    .pill{padding:4px 10px;border:1px solid var(--border);border-radius:999px;background:linear-gradient(180deg,#0e1623,#0b111a);color:var(--muted)}
    .accent{border-color:#1b3342;box-shadow:0 0 0 1px rgba(106,227,255,.12) inset}
    .tabs{margin-left:auto;display:flex;gap:8px}
    .tab{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(180deg,#0f1722,#0c121b);cursor:pointer;color:var(--muted)}
    .tab.active{color:var(--fg);border-color:#254056;box-shadow:0 0 0 1px rgba(106,227,255,.12) inset}
    main{max-width:1200px;margin:0 auto;padding:16px;display:grid;grid-template-columns:320px 1fr;gap:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);overflow:hidden}
    .card h3{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#0f1722,#0c121b)}
    .section{padding:12px 14px;display:grid;gap:10px}
    label{font-size:12px;color:var(--muted)}
    input[type="text"], input[type="password"], textarea, select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0b121a;color:var(--fg)}
    textarea{min-height:120px;resize:vertical}
    button{padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:linear-gradient(180deg,#162332,#0f1722);color:var(--fg);cursor:pointer}
    button.primary{border-color:#24475a;background:linear-gradient(180deg,#113142,#0d2230);box-shadow:0 0 0 1px rgba(106,227,255,.2) inset}
    button.ghost{background:transparent}
    .row{display:flex;gap:8px;align-items:center}
    .row > *{flex:1}
    .kvs{display:flex;flex-wrap:wrap;gap:6px}
    .kv{background:#0c131c;border:1px solid var(--border);padding:6px 10px;border-radius:999px;color:var(--muted)}
    .chat{display:flex;flex-direction:column;height:100%}
    .messages{flex:1;overflow:auto;padding:12px}
    .msg{padding:10px 12px;margin:8px 0;border:1px solid var(--border);border-radius:14px;max-width:80%}
    .msg.user{margin-left:auto;background:#0e1b25}
    .msg.assistant{background:#0d131b}
    .composer{display:flex;gap:8px;padding:12px;border-top:1px solid var(--border);background:linear-gradient(180deg,#0f1722,#0c121b)}
    .composer textarea{min-height:56px}
    .badges{display:flex;gap:8px;align-items:center}
    .badge{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted)}
    .stat{font-size:12px;color:var(--muted)}
    .small{font-size:12px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
    .green{color:var(--ok)} .yellow{color:var(--warn)} .red{color:var(--danger)}
    .grid{display:grid;gap:10px}
    .two{grid-template-columns:1fr 1fr}
    .three{grid-template-columns:repeat(3,1fr)}
    .hint{color:var(--muted);font-size:12px}
    .spacer{height:8px}
    .hidden{display:none}
    .right{justify-content:flex-end}
    .chip{border:1px dashed var(--border);color:var(--muted);padding:4px 8px;border-radius:999px}
    .progress{height:8px;background:#0c131c;border:1px solid var(--border);border-radius:999px;overflow:hidden}
    .progress > div{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2))}
    .tests{font-size:12px; background:#0c131c; border:1px solid var(--border); border-radius:12px; padding:10px; white-space:pre-wrap}
    .pass{color:#7ee787}
    .fail{color:#ff7b72}
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="bar">
      <div class="logo">
        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M7 7h10v10H7z" stroke="var(--accent)"/><path d="M3 3h6v6H3zM15 15h6v6h-6z" stroke="var(--accent-2)"/></svg>
        <span>AIME</span>
        <span class="pill accent">Local / API</span>
        <span class="pill">Personalized Indexes</span>
      </div>
      <div class="tabs">
        <button class="tab active" data-tab="chat">Chat</button>
        <button class="tab" data-tab="indexes">Indexes</button>
        <button class="tab" data-tab="sources">Sources</button>
        <button class="tab" data-tab="settings">Settings</button>
      </div>
    </div>
  </header>
  <main>
    <!-- Left column: Controls -->
    <div class="card" id="left-pane">
      <h3>Model & Retrieval</h3>
      <div class="section grid">
        <label>Model Backend</label>
        <div class="row">
          <select id="backend">
            <option value="webllm">Local (WebLLM/WebGPU)</option>
            <option value="openai">OpenAI API</option>
            <option value="anthropic">Anthropic API</option>
            <option value="ollama">Ollama (local server)</option>
          </select>
          <button id="init-backend">Init</button>
        </div>
        <div id="backend-status" class="stat">Not initialized.</div>
        <div class="spacer"></div>
        <label>Retrieval Settings</label>
        <div class="row">
          <select id="active-index"></select>
          <button id="refresh-indexes">↻</button>
        </div>
        <div class="row">
          <label class="small">Top‑k</label>
          <input type="text" id="topk" value="6" />
          <label class="small">Max prompt ctx (chars)</label>
          <input type="text" id="ctxmax" value="8000" />
        </div>
        <div class="row">
          <label class="small">Rerank?</label>
          <select id="rerank">
            <option value="off">Off</option>
            <option value="bm25">BM25 (light)</option>
          </select>
          <label class="small">Chunk size</label>
          <input type="text" id="chunksize" value="900" />
        </div>
        <div class="kvs" id="active-tags"></div>
      </div>
      <h3>Quick Actions</h3>
      <div class="section grid two">
        <div>
          <label>WebLLM Local Model</label>
          <select id="webllm-model">
            <option value="Qwen2.5-1.5B-Instruct-q4f16_1-MLC">Qwen2.5‑1.5B (fast, tiny)</option>
            <option value="Qwen2.5-7B-Instruct-q4f16_1-MLC">Qwen2.5‑7B (balanced)</option>
            <option value="Llama-3.1-8B-Instruct-q4f16_1-MLC">Llama 3.1 8B (balanced)</option>
          </select>
        </div>
        <div>
          <label>Default OpenAI Model</label>
          <select id="openai-model">
            <option value="gpt-4o-mini">gpt‑4o‑mini</option>
            <option value="gpt-4o">gpt‑4o</option>
            <option value="gpt-4.1">gpt‑4.1</option>
          </select>
        </div>
      </div>
      <div class="section grid two">
        <div>
          <label>Ollama Base URL</label>
          <input type="text" id="ollama-base" placeholder="http://localhost:11434" />
        </div>
        <div>
          <label>Ollama Model</label>
          <input type="text" id="ollama-model" placeholder="llama3.1:8b-instruct" />
        </div>
      </div>
      <div class="section">
        <label>System Prompt</label>
        <textarea id="system-prompt" class="mono" placeholder="You are AIME. Use retrieved context chunks to answer as the user's long‑term collaborator. Cite sources by title."></textarea>
        <div class="row right">
          <button id="save-settings" class="primary">Save Settings</button>
        </div>
      </div>
      <div class="section">
        <div class="row">
          <button id="run-tests">Run Self Tests</button>
          <span class="hint">Quick diagnostics for core utilities.</span>
        </div>
        <div id="test-output" class="tests"></div>
      </div>
    </div>

    <!-- Right column: Tab content -->
    <div class="card chat" id="tab-chat">
      <div class="messages" id="messages"></div>
      <div class="composer">
        <textarea id="prompt" placeholder="Ask with context…"></textarea>
        <div class="grid">
          <button id="send" class="primary">Send</button>
          <button id="stop" class="ghost">Stop</button>
        </div>
      </div>
    </div>

    <div class="card hidden" id="tab-indexes">
      <h3>Indexes</h3>
      <div class="section">
        <div class="row">
          <input type="text" id="index-name" placeholder="Index name (e.g., Ben • Siloti Studies)" />
          <input type="text" id="index-tags" placeholder="tags: thesis, siloti, recital" />
          <button id="create-index" class="primary">Create</button>
        </div>
        <div id="index-list" class="grid"></div>
      </div>
    </div>

    <div class="card hidden" id="tab-sources">
      <h3>Sources</h3>
      <div class="section">
        <div class="row">
          <select id="source-index"></select>
          <button id="import-file">Import .txt / .md</button>
          <button id="import-url">Fetch URL</button>
        </div>
        <textarea id="source-text" placeholder="Paste text here…"></textarea>
        <div class="row right">
          <button id="save-source" class="primary">Save Source</button>
        </div>
        <div id="sources-list" class="grid"></div>
      </div>
    </div>

    <div class="card hidden" id="tab-settings">
      <h3>Settings</h3>
      <div class="section"><span class="hint">Use the left panel for all settings.</span></div>
    </div>
  </main>
</div>

<!-- WebLLM (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@0.2.76/dist/web-llm.min.js"></script>

<!-- App Module -->
<script type="module">
  import * as localforage from 'https://cdn.jsdelivr.net/npm/localforage@1.10.0/+esm';
  import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@3.2.0/+esm';
  env.allowLocalModels = false;

  const qs = sel => document.querySelector(sel);
  const qsa = sel => Array.from(document.querySelectorAll(sel));

  const state = {
    backend: 'webllm',
    webllm: { engine: null, ready: false },
    openai: { key: '', model: 'gpt-4o-mini' },
    anthropic: { key: '' },
    ollama: { base: 'http://localhost:11434', model: 'llama3.1:8b-instruct', ready: false },
    systemPrompt: 'You are AIME. Use retrieved context to answer as a long-term collaborator. Cite source titles inline when useful.',
    indexes: [],
    sources: [],
    vectors: [],
    activeIndexId: null,
    embedding: { pipe: null, ready: false },
    aborter: null,
  };

  const DB = {
    get: k => localforage.getItem(k),
    set: (k,v) => localforage.setItem(k,v),
  };
  const saveConf = async (patch) => DB.set('conf', { ...(await DB.get('conf'))||{}, ...patch });

  async function loadAll(){
    state.indexes = (await DB.get('indexes')) || [];
    state.sources = (await DB.get('sources')) || [];
    state.vectors = (await DB.get('vectors')) || [];
    const conf = (await DB.get('conf')) || {};
    state.backend = conf.backend || state.backend;
    state.openai.key = conf.openaiKey || '';
    state.openai.model = conf.openaiModel || state.openai.model;
    state.anthropic.key = conf.anthropicKey || '';
    state.ollama.base = conf.ollamaBase || state.ollama.base;
    state.ollama.model = conf.ollamaModel || state.ollama.model;
    state.systemPrompt = conf.systemPrompt || state.systemPrompt;
    state.activeIndexId = conf.activeIndexId || (state.indexes[0]?.id ?? null);
    hydrateUI();
    await initEmbedding();
  }

  function hydrateUI(){
    qsa('.tab').forEach(btn => btn.addEventListener('click', () => switchTab(btn.dataset.tab)));
    qs('#openai-model').value = state.openai.model;
    qs('#system-prompt').value = state.systemPrompt;
    qs('#ollama-base').value = state.ollama.base;
    qs('#ollama-model').value = state.ollama.model;

    const idxSel = qs('#active-index');
    const srcSel = qs('#source-index');
    idxSel.innerHTML = '';
    srcSel.innerHTML = '';
    state.indexes.forEach(ix => {
      const o1 = document.createElement('option'); o1.value = ix.id; o1.textContent = ix.name; idxSel.appendChild(o1);
      const o2 = document.createElement('option'); o2.value = ix.id; o2.textContent = ix.name; srcSel.appendChild(o2);
    });
    if(state.activeIndexId) idxSel.value = state.activeIndexId;

    renderIndexList();
    renderSourcesList();
    qs('#backend').value = state.backend;
  }

  function switchTab(name){
    qsa('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === name));
    ['chat','indexes','sources','settings'].forEach(id => qs('#tab-'+id).classList.toggle('hidden', id!==name));
  }

  function renderIndexList(){
    const el = qs('#index-list'); if(!el) return; el.innerHTML = '';
    state.indexes.forEach(ix => {
      const used = state.sources.filter(s => s.indexId===ix.id).length;
      const row = document.createElement('div');
      row.className = 'section';
      row.innerHTML = `
        <div class="row">
          <div>
            <div><strong>${ix.name}</strong></div>
            <div class="hint">${ix.tags.join(', ') || 'no tags'} • ${used} sources</div>
          </div>
          <div class="badges">
            <button data-act="select" data-id="${ix.id}">Activate</button>
            <button data-act="export" data-id="${ix.id}">Export</button>
            <button data-act="delete" data-id="${ix.id}" class="ghost">Delete</button>
          </div>
        </div>`;
      row.addEventListener('click', async (e)=>{
        const id = e.target.getAttribute('data-id');
        const act = e.target.getAttribute('data-act');
        if(!id||!act) return;
        if(act==='select'){ state.activeIndexId = id; await saveConf({ activeIndexId:id }); hydrateUI(); }
        if(act==='export') exportIndex(id);
        if(act==='delete') deleteIndex(id);
      });
      el.appendChild(row);
    });
  }

  async function deleteIndex(id){
    if(!confirm('Delete index and its vectors?')) return;
    state.indexes = state.indexes.filter(i=>i.id!==id);
    state.sources = state.sources.filter(s=>s.indexId!==id);
    state.vectors = state.vectors.filter(v=>v.indexId!==id);
    await DB.set('indexes', state.indexes);
    await DB.set('sources', state.sources);
    await DB.set('vectors', state.vectors);
    hydrateUI();
  }

  async function exportIndex(id){
    const ix = state.indexes.find(i=>i.id===id);
    const payload = {
      index: ix,
      sources: state.sources.filter(s=>s.indexId===id),
      vectors: state.vectors.filter(v=>v.indexId===id)
    };
    const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = (ix?.name||'index')+'.aime.json'; a.click();
    URL.revokeObjectURL(url);
  }

  qs('#create-index')?.addEventListener('click', async ()=>{
    const name = qs('#index-name').value.trim();
    if(!name) return alert('Name required');
    const tags = qs('#index-tags').value.split(',').map(s=>s.trim()).filter(Boolean);
    const id = crypto.randomUUID();
    state.indexes.push({id,name,tags,createdAt:Date.now()});
    state.activeIndexId = id;
    await DB.set('indexes', state.indexes);
    await saveConf({ activeIndexId:id });
    hydrateUI();
  });

  function renderSourcesList(){
    const el = qs('#sources-list'); if(!el) return; el.innerHTML = '';
    const rows = state.sources.filter(s=>!state.activeIndexId || s.indexId===state.activeIndexId);
    rows.forEach(s => {
      const used = state.vectors.filter(v=>v.sourceId===s.id).length;
      const div = document.createElement('div');
      div.className='section';
      div.innerHTML = `<div><strong>${s.title}</strong> <span class="hint">${used} chunks • ${(s.text.length/1000).toFixed(1)}k chars</span></div>`;
      el.appendChild(div);
    })
  }

  qs('#save-source')?.addEventListener('click', async ()=>{
    const indexId = qs('#source-index').value || state.activeIndexId;
    if(!indexId) return alert('Create/select an index first');
    const text = qs('#source-text').value.trim();
    if(!text) return alert('Paste some text');
    const id = crypto.randomUUID();
    const title = text.slice(0,60).replace(/\s+/g,' ').trim()+ (text.length>60?'…':'');
    state.sources.push({id,indexId,title,text,createdAt:Date.now()});
    await DB.set('sources', state.sources);
    qs('#source-text').value='';
    renderSourcesList();
  });

  qs('#import-url')?.addEventListener('click', async ()=>{
    const url = prompt('Enter a URL to fetch as text:');
    if(!url) return;
    try{
      const res = await fetch(url);
      const txt = await res.text();
      qs('#source-text').value = txt;
    }catch(e){ alert('Failed to fetch. Paste manually.'); }
  });

  qs('#import-file')?.addEventListener('click', ()=>{
    const input = document.createElement('input');
    input.type='file'; input.accept='.txt,.md';
    input.onchange = async ()=>{
      const file = input.files[0]; if(!file) return;
      const txt = await file.text();
      qs('#source-text').value = txt;
    };
    input.click();
  });

  let embedderPromise = null;

  async function initEmbedding(){
    try{
      qs('#backend-status').textContent = 'Loading embedding model (Xenova e5-small-v2)…';
      embedderPromise = pipeline('feature-extraction', 'Xenova/e5-small-v2');
      state.embedding.pipe = await embedderPromise;
      state.embedding.ready = true;
      qs('#backend-status').textContent = 'Embedding model ready.';
    }catch(e){
      console.error(e);
      qs('#backend-status').textContent = 'Embedding failed to load.';
    }
  }

  function chunkText(text, size){
    const chunks = [];
    let i=0; while(i<text.length){
      const end = Math.min(i+size, text.length);
      let slice = text.slice(i,end);
      const lastBreak = slice.lastIndexOf('\n\n');
      if(lastBreak>size*0.6 && end<text.length){ slice = slice.slice(0,lastBreak+2); i += lastBreak+2; }
      else { i = end; }
      chunks.push(slice.trim());
    }
    return chunks.filter(Boolean);
  }

  function cosine(a,b){
    let dot=0,na=0,nb=0; for(let i=0;i<a.length;i++){ const x=a[i], y=b[i]; dot+=x*y; na+=x*x; nb+=y*y; }
    return dot/(Math.sqrt(na)*Math.sqrt(nb)+1e-8);
  }

  async function embed(text){
    const pipe = state.embedding.pipe || await embedderPromise;
    const out = await pipe(text, { pooling: 'mean', normalize: true });
    return Array.from(out.data);
  }

  async function reembedActive(){
    if(!state.activeIndexId) return alert('Select an index');
    const size = parseInt(qs('#chunksize').value||'900',10);
    const progress = qs('#embed-progress');
    if(progress){ progress.style.display='block'; progress.firstElementChild.style.width='0%'; }
    const srcs = state.sources.filter(s=>s.indexId===state.activeIndexId);
    state.vectors = state.vectors.filter(v=>v.indexId!==state.activeIndexId);
    let done=0, total=Math.max(1, srcs.length);
    for(const s of srcs){
      const chunks = chunkText(s.text, size);
      let cid=0;
      for(const ch of chunks){
        const vec = await embed(ch);
        state.vectors.push({
          id: crypto.randomUUID(), indexId: state.activeIndexId, sourceId: s.id, chunkId: cid++, embedding: vec, text: ch
        });
      }
      done++; if(progress){ progress.firstElementChild.style.width = f"{round(done/total*100)}%"; }
      await DB.set('vectors', state.vectors);
    }
    await DB.set('vectors', state.vectors);
    if(progress){ progress.style.display='none'; }
    alert('Embedding complete');
  }

  qs('#btn-embed-all')?.addEventListener('click', reembedActive);
  qs('#refresh-indexes')?.addEventListener('click', hydrateUI);
  qs('#btn-new-index')?.addEventListener('click', ()=> switchTab('indexes'));
  qs('#btn-add-source')?.addEventListener('click', ()=> switchTab('sources'));
  qs('#btn-export')?.addEventListener('click', ()=> state.activeIndexId && exportIndex(state.activeIndexId));

  function bm25Score(qTerms, doc){
    const words = doc.toLowerCase().split(/\W+/g);
    let score = 0; for(const t of qTerms){
      const tf = words.filter(w=>w===t).length; if(tf>0) score += 1 + Math.log(1+tf);
    }
    return score;
  }

  async function retrieve(query){
    const k = parseInt(qs('#topk').value||'6',10);
    const ctxMax = parseInt(qs('#ctxmax').value||'8000',10);
    const rerank = qs('#rerank').value;
    const vecs = state.vectors.filter(v=>v.indexId===state.activeIndexId);
    if(vecs.length===0) return [];
    const qvec = await embed(query);
    const scored = vecs.map(v=> ({...v, score: cosine(qvec, v.embedding)}));
    scored.sort((a,b)=>b.score-a.score);
    let top = scored.slice(0, Math.max(k*4, k));
    if(rerank!=='off'){
      const terms = query.toLowerCase().split(/\W+/g).filter(Boolean);
      top.forEach(v=> { v.score2 = v.score + 0.1 * bm25Score(terms, v.text); });
      top.sort((a,b)=>b.score2-a.score2);
    }
    let pack=[], total=0; for(const v of top){
      if(pack.length>=k) break;
      if(total + v.text.length > ctxMax) continue;
      pack.push(v); total += v.text.length;
    }
    return pack;
  }

  function renderMessage(role, html){
    const el = document.createElement('div');
    el.className = 'msg '+(role==='user'?'user':'assistant');
    el.innerHTML = html;
    qs('#messages').appendChild(el);
    qs('#messages').scrollTop = qs('#messages').scrollHeight;
    return el;
  }

  async function initBackend(){
    const backend = qs('#backend').value; state.backend = backend;
    await saveConf({ backend });

    if(backend==='webllm'){
      try{
        qs('#backend-status').textContent = 'Initializing WebLLM…';
        const sel = qs('#webllm-model').value;
        const engine = new window.webllm.MLCEngine();
        await engine.reload({ model: sel });
        state.webllm.engine = engine; state.webllm.ready = true;
        qs('#backend-status').innerHTML = `Local model ready <span class="badge">${sel}</span>`;
      }catch(e){
        console.error(e); qs('#backend-status').textContent = 'WebLLM init failed (check WebGPU support).';
      }
    }
    if(backend==='openai'){
      const key = prompt('Enter your OpenAI API key (stored locally):', state.openai.key || '');
      if(!key) return alert('Enter OpenAI key to use this backend.');
      state.openai.key = key; state.openai.model = qs('#openai-model').value;
      await saveConf({ openaiKey:key, openaiModel: state.openai.model });
      qs('#backend-status').textContent = `OpenAI ready: ${state.openai.model}`;
    }
    if(backend==='anthropic'){
      const key = prompt('Enter your Anthropic API key (stored locally):', state.anthropic.key || '');
      if(!key) return alert('Enter Anthropic key to use this backend.');
      state.anthropic.key = key;
      await saveConf({ anthropicKey:key });
      qs('#backend-status').textContent = 'Anthropic ready (Claude)';
    }
    if(backend==='ollama'){
      const base = (qs('#ollama-base').value || 'http://localhost:11434').replace(/\/$/, '');
      const model = qs('#ollama-model').value || 'llama3.1:8b-instruct';
      state.ollama.base = base; state.ollama.model = model;
      await saveConf({ ollamaBase: base, ollamaModel: model });
      try {
        const res = await fetch(base + '/api/version');
        if(!res.ok) throw new Error('HTTP '+res.status);
        state.ollama.ready = true;
        qs('#backend-status').textContent = `Ollama ready: ${model}`;
      } catch (e) {
        state.ollama.ready = false;
        qs('#backend-status').textContent = 'Could not reach Ollama at '+base+' (enable server & CORS).';
      }
    }
  }
  qs('#init-backend').addEventListener('click', initBackend);

  qs('#save-settings').addEventListener('click', async ()=>{
    state.openai.model = qs('#openai-model').value;
    state.systemPrompt = qs('#system-prompt').value;
    await saveConf({
      openaiModel: state.openai.model, systemPrompt: state.systemPrompt,
      ollamaBase: qs('#ollama-base').value, ollamaModel: qs('#ollama-model').value
    });
    alert('Saved');
  });

  qs('#send').addEventListener('click', async ()=>{
    const p = qs('#prompt').value.trim(); if(!p) return;
    renderMessage('user', escapeHtml(p));
    qs('#prompt').value = '';
    const placeholder = renderMessage('assistant', '<span class="hint">Thinking…</span>');

    const retrieved = await retrieve(p);
    const ctx = retrieved.map((v,i)=>`<CTX id="${i}" source="${titleFor(v.sourceId)}">\n${escapeHtml(v.text)}\n</CTX>`).join('\n\n');

    const sys = state.systemPrompt + `\n\nYou have access to ${retrieved.length} context chunks. Quote minimally and attribute by source title when relevant.`;

    try{
      const reply = await generate(sys, p, ctx);
      placeholder.innerHTML = md(reply);
    }catch(e){
      placeholder.innerHTML = `<span class="red small">${escapeHtml(String(e.message||e))}</span>`;
    }
  });

  qs('#stop').addEventListener('click', ()=>{ if(state.aborter) state.aborter.abort('user'); });

  function titleFor(sourceId){ return state.sources.find(s=>s.id===sourceId)?.title || 'Untitled'; }
  function assemblePrompt(system, user, context){ const intro = `<CONTEXT>\n${context}\n</CONTEXT>`; return { system, user, intro }; }

  async function generate(system, user, context){
    const backend = state.backend;
    const { system: sys, user: usr, intro } = assemblePrompt(system, user, context);

    if(backend==='webllm' && state.webllm.ready){
      const engine = state.webllm.engine;
      const messages = [ {role:'system', content: sys}, {role:'user', content: intro + "\n\n" + usr} ];
      const resp = await engine.chat.completions.create({ messages, stream:false, temperature:0.3 });
      return resp?.choices?.[0]?.message?.content || resp?.output_text || '';
    }

    if(backend==='openai' && state.openai.key){
      const ctl = new AbortController(); state.aborter = ctl;
      const res = await fetch('https://api.openai.com/v1/chat/completions',{
        method:'POST', headers:{
          'Authorization': `Bearer ${state.openai.key}`,
          'Content-Type': 'application/json'
        }, body: JSON.stringify({
          model: state.openai.model,
          messages:[{role:'system', content: sys},{role:'user', content: intro + "\n\n" + usr}],
          temperature:0.3, stream:false
        }), signal: ctl.signal
      });
      if(!res.ok){ throw new Error('OpenAI: '+res.status+' '+res.statusText); }
      const json = await res.json();
      return json.choices?.[0]?.message?.content || '';
    }

    if(backend==='anthropic' && state.anthropic.key){
      const ctl = new AbortController(); state.aborter = ctl;
      const res = await fetch('https://api.anthropic.com/v1/messages',{
        method:'POST', headers:{
          'x-api-key': state.anthropic.key,
          'anthropic-version': '2023-06-01',
          'Content-Type': 'application/json'
        }, body: JSON.stringify({
          model: 'claude-3-5-sonnet-20240620',
          system: sys,
          max_tokens: 1024,
          messages:[{role:'user', content: intro + "\n\n" + usr}],
        }), signal: ctl.signal
      });
      if(!res.ok){ throw new Error('Anthropic: '+res.status+' '+res.statusText); }
      const json = await res.json();
      return json.content?.[0]?.text || '';
    }

    if(backend==='ollama' && state.ollama.ready){
      const ctl = new AbortController(); state.aborter = ctl;
      const url = state.ollama.base.replace(/\/$/, '') + '/api/chat';
      const body = {
        model: state.ollama.model,
        messages: [
          { role: 'system', content: sys },
          { role: 'user', content: intro + "\n\n" + usr }
        ],
        stream: false,
        options: { temperature: 0.3 }
      };
      const res = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body), signal: ctl.signal });
      if(!res.ok){ throw new Error('Ollama: '+res.status+' '+res.statusText); }
      const json = await res.json();
      const text = json?.message?.content || (json?.messages?.map(m=>m.content).join('\n') if isinstance(json.get('messages'), list) else '');
      return text;
    }

    throw new Error('No backend ready. Initialize in the left panel.');
  }

  function escapeHtml(s){ return s.replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c])); }
  function md(text){
    let t = escapeHtml(text);
    t = t.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    t = t.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    t = t.replace(/`([^`]+)`/g, '<code>$1</code>');
    t = t.split(/\n\n+/).map(p=>`<p>${p.replace(/\n/g,'<br/>')}</p>`).join('');
    return t;
  }

  qs('#backend').addEventListener('change', e=> state.backend = e.target.value);
  qs('#active-index').addEventListener('change', async e=>{ state.activeIndexId = e.target.value; await saveConf({ activeIndexId: state.activeIndexId }); });

  function assert(name, cond){ return { name, ok: !!cond, msg: cond? 'OK' : 'FAILED' }; }
  function near(a,b,eps=1e-3){ return Math.abs(a-b) <= eps; }

  function runSelfTests(){
    const results = [];
    results.push(assert('transformers.env defined', typeof env === 'object'));
    results.push(assert('env.allowLocalModels exists', 'allowLocalModels' in env));
    const sample = 'p1 line\n\npara2 text';
    const chunks = chunkText(sample, 8);
    results.push(assert('chunkText -> 2 chunks with small size', chunks.length === 2));
    const v1 = [1,0,0], v2 = [1,0,0], v3=[0,1,0];
    results.push(assert('cosine(identical) ≈ 1', near(cosine(v1,v2),1)));
    results.push(assert('cosine(orthogonal) ≈ 0', near(cosine(v1,v3),0,1e-6)));
    const bscore = bm25Score(['test','alpha'], 'alpha beta test test');
    results.push(assert('bm25Score positive for present terms', bscore > 0));
    const out = results.map(r=> `${r.ok? '✅':''}${!r.ok? '❌':''} ${r.name} — ${r.msg}`).join('\n');
    const el = qs('#test-output'); if(el){ el.textContent = out; }
    console.table(results);
  }
  qs('#run-tests')?.addEventListener('click', runSelfTests);

  await loadAll();

  if(state.indexes.length===0){
    const id = crypto.randomUUID();
    state.indexes.push({id, name:'My First Index', tags:['personal'], createdAt:Date.now()});
    await DB.set('indexes', state.indexes);
    state.activeIndexId = id; await saveConf({ activeIndexId:id });
    hydrateUI();
  }
</script>
</body>
</html>
